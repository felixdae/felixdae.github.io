---

title: 来自圣经的算法(出自matrix67.com)
---

{{ page.title }}
===============

《来自圣经的证明》收集了数十个简洁而优雅的数学证明，迅速赢得了大批数学爱好者的追捧。如果还有一本《来自圣经的算法》，哪些算法会列入其中呢？最近，有人在[StackExchange](http://cstheory.stackexchange.com/questions/189/algorithms-from-the-book)上发起了提问，向网友们征集那些来自圣经的算法。众人在一大堆入围算法中进行投票，最终得出了呼声最高的五个算法：

## 第五名： BFPRT 算法 

1973 年， Blum 、 Floyd 、 Pratt 、 Rivest 、 Tarjan 集体出动，合写了一篇题为 “Time bounds for selection” 的论文，给出了一种在数组中选出第 k 大元素的算法，俗称"中位数之中位数算法"。依靠一种精心设计的 pivot 选取方法，该算法从理论上保证了最坏情形下的线性时间复杂度，打败了平均线性、最坏 O(n^2) 复杂度的传统算法。一群大牛把递归算法的复杂度分析玩弄于骨掌股掌之间，构造出了一个当之无愧的来自圣经的算法。

## 第四名：快速排序 

快速排序算法是 1960 年由英国计算机科学家 C.A.R. Hoare 发明的，是一种既高效又简洁的排序方法，现在已是学习算法的必修内容之一。快速排序的思想并不复杂，妙就妙在那个线性的数据分割过程，而真正最牛 B 的则是对整个算法的时间复杂度分析。我曾写过一个 [快速排序平均 O(n log n) 的证明](http://www.matrix67.com/blog/archives/172)，分析过程绝对值得欣赏。

## 第三名：并查集 

严格地说，并查集是一种数据结构，它专门用来处理集合的合并操作和查询操作。并查集巧妙地借用了树结构，使得编程复杂度降低到了令人难以置信的地 步；用上一些递归技巧后，各种操作几乎都能用两行代码搞定。而路径压缩的好主意，更是整个数据结构的画龙点睛之笔。并查集的效率极高，单次操作的时间复杂 度几乎可以看作是常数级别；但由于数据结构的实际行为难以预测，精确的时间复杂度分析需要用到不少高深的技巧。

## 第二名： KMP 算法 

KMP 算法是一种非常有效的字符串匹配算法，它告诉了人们一个有些反直觉的事实：字符串匹配竟然能在线性时间里完成！整个算法写成代码不足 10 行，但其中蕴含的天才般的奇妙思想让算法初学者们望而却步，而它的复杂度分析则更是堪称经典。

                       
## 第一名：辗转相除法 

辗转相除法是 Euclid 的《几何原本》中提到的一种寻找两个数的最大公因数的算法。无论是简洁的算法过程，还是深刻的算法原理，抑或是巧妙的复杂度分析，都称得上是来自圣经的算 法。而扩展的辗转相除法则构造性地证明了，对任意整数 a 和 b ，存在一对 x 、 y 使得 ax + by = gcd(a, b) 。这一结论的普遍性和实用性让它成为了数论中的基本定理之一，在很多数学问题中都能看到它的身影。

