---

title: 右值，右值引用以及move语意
---

{{ page.title }}
===============

最新c++标准引入了新特性：右值引用。通过使用右值引用可以实现move语意，从而减少对于大型复杂结构不必要的复制，从而极大地提高执行效率。

什么是右值？右值是个古老的概念，源于c语言，其对定义是这样的：只能放到赋值符号“=”右边的表达式则为右值，否则则为左值。例如：

<pre>
<code>
int a = 42;
int b = 43;
   
// a and b are both l-values:
a = b; // ok
b = a; // ok
a = a * b; // ok

// a * b is an rvalue:
int c = a * b; // ok, rvalue on right hand side of assignment
a * b = 42; // error, rvalue on left hand side of assignment
</code>
</pre>

由于自定义类型的引入，该定义对c++不再适用，下面的这个定义可能更适合c++一些，虽然也不完全准确：能对其使用取地址操作（&）的即为左值，否则为右值。

右值引用即是对右值的引用，c++新标准中的语法可写为T&&。

右值引用的引入主要是为了解决自定义复杂类型的复制问题。于是适用于右值引用的新copy constructor和copy assignment operator也被引入了。

<pre>
<code>
T(T&& rhs);
T& operator=(T&& rhs)
</code>
</pre>

参数类型为右值则会自动调用右值引用版的copy constructor和copy assignment operator，否则将会调用传统版。

右值引用版的这两个函数，都会把参数对象的内部资源直接传递给新对象，并把参数对象对其内部资源的引用或者指针置为空。很明显这样做实现了内部资源的转移，即move语意，但为什么要把被引用对象对资源的引用置为空呢？原因在于被引用对象是右值，右值的特征在于易失性，如果不将其对资源的引用置为空，则在其析构的时候将会释放资源，从而对新构造对象造成影响，这样显然已经有悖于move语意的初衷，而且在实际中也是毫无意义的。

右值引用本身是左值还是右值？这一问题取决于该右值引用是否具名，具名右值是左值，因为其有名字，就有在后续代码被使用的可能性，前面已经指出在move语意中，被引用右值资源被传递，本身对资源的引用置为空，如果其同样被视为右值适用于move语意，则显然后续对其的使用会有问题，因为其占有资源已经被传递了。不具名右值引用显然不存在这方面的问题，因为后续代码再也引用不到它了，对其修改从而不会有什么副作用。

