---
layout: post
title: base64编解码算法所引出的关于位操作的想法
---

{{ page.title }}
===============

开始新项目，要搭建c/c++开发的基础代码库。作为互联网项目，base64编解码功能是免不掉的，其中细节可以参考[这里](http://zh.wikipedia.org/zh-cn/Base64)，简单说来就是将连续的3字节共24个bit按6bit一块分成4块。6bit的只有64种取值可能，就可以将它们映射到64种可打印字符，于是3字节的数据就转换成了4字节的可打印字符串。

直接实现这一算法的方法是，依次按位操作字符，凑成4个块，再进行映射，伪码大致如下：

<pre>
<code>
char a1 = map[str[0]>>2];
char a2 = map[((str[0]<<4)&0x30)^(str[1]>>4)];
char a3 = map[((str[1]<<2)&0x3c)^(str[2]>>6)];
char a4 = map[str[2]&0x3f];
</code>
</pre>

第一版的代码就是这样写的，但我总觉得很别扭，位操作使用的太多，另外要跨字符，代码的可读性很差，对其正确性也不是很有信心。

反复琢磨，想到或许可以将3个字符串当成一个整体来处理，具体做法就是将其内容拷贝到一个4字节的整形变量的地址上：

<pre>
<code>
uint32_t container = 0;
memcpy((char*)&container + 1, str, 3);
container = htonl(container);
a1 = map[(container>>18)&0x3f];
a2 = map[(container>>12)&0x3f];
a3 = map[(container>>6)&0x3f];
a4 = map[(container>>0)&0x3f];
</code>
</pre>

毫无疑问第二种写法更清晰，出错的可能性也更小。

这里要解释一下对htonl的调用，该函数是tcp/ip协议栈中的工具函数，用来将变量从主机序转换成网络序以适应网络传输。为什么要使用它？因为调试和将来运行代码的机器都是x86架构的，这一架构的数据存储是高有效字节放在高地址，即所谓的[little endian](http://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F)，如果不进行转换，将得到错误的结果。过程描述如下，假定3字节内容为0xAa，0xBb，0xCc。

memcpy之后，container的内容是00AaBbCc，地址从低到高，其整数类型值为0xCcBbAa00，如果不进行htonl转换，结果显然会错误。相反进行转换之后，container内存布局为CcBbAa00，整数值为0x00AaBbCc，这种情况正好是我们所需要的，之后的位操作也就不会出错。

其实以上论证暗含了两个假设，我也是在调试的过程中才弄明白，之前也是一直浑浑噩噩。其一是所谓字节序问题其实是基于字节层面上的，而不涉及bit位，主机序和网络序的转换只牵涉到字节顺序的改变，而一个字节内部的各bit的相对位置是不会改变的，其实这一点从“字节序”这三个字也可以体会到。其二是c语言中的位操作是针对其逻辑表达的，而跟其在内存上的物理布局无关，也就是说(0xAABBCCDD>>4)&(0xFF00)不管在何种架构的机器上，其结果都应为0x0000BC00。我们可以发现网络序与我们对内存内容的逻辑表达是一致的，从而也更便于我们对连续内存做位操作。

